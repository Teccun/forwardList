#pragma once
#include "ListAbstract.h"
#include "Mem.h"

class List : public AbstractList
{
private:

	// количество элементов в списке
	size_t list_Size;  

	//размер листа в байтах
	size_t mem_Size_List;

public:

	//класс исключения в случае, когда итератор является не валидным
	//Это может произойти, когда два итератора указывали на один и тот же объект
	//И один из них использовал remove или insert. Это полвекло за собой повреждение ссылок второго итератора
	//Или когда два итератора находятся друг за другом и один исолнил remove.
	class IterError
	{
	public:
		IterError() {}
	};
	//Класс исключения в случае, когда список пуст и произовдиться попытка remove
	class EmptyError
	{
	public:
		EmptyError() {}
	};

	//Конструктор List
	//Принимает константую ссылку на объект типа MemoryManager.
	//head указывает на nullptr
	//list_size устанавливается в 0
	List(MemoryManager& mem); 

	//деструктор List
	//Удаляет все элементы в списке, очищает его.
	//использует метод clear()
	~List();

	//Методы из ListAbstract.h

	//добавление элемента в начало списка
	//На вход принимает ссылку на область памяти и размер этой области памяти
	//На выходе выдает 0 в случае успеха, иначе 1
	//Выделяет блок памяти с помощью MemoryManger, переносит побитово в эту область памяти некотурую информацию
	//Создает узел, Node, который сохраняет ссылку на эту область памяти и размер данной памяти
	//новый элемент становиться head, головным элементом списка.
	//Увеличивает счетчик занятой памяти (mem_Size_List) в MemoryManager и инкрементирует счетчик узлов в списке (list_Size)
	int push_front(void* elem, size_t elemSize);						
	
	//удаление элемента из начала списка 
	//Вариант реализации - недействительный: Вызывает исключение, если haed списка есть nullptr
	//Вариант реализации - действительный: При head == nullptr метод завершается без удаления.
	//В противном случае освобождает выделенную память в MemoryManager
	//Умеьшаяются значения mem_Size_List и list_Size.
	//Удаление самого Node из List.
	void pop_front();													

	//добавление нового элемента на позицию на которую указывает итератор
	//Принимает на вход итератор, указатель на область бамяти, в который содержиться элемент, который будем добавлять, и размер этого элемента в байтах
	//В случае успешного добавления функция возвращает значение 0, в случае неудачи 1
	//Выделяет блок памяти с помощью MemoryManger, переносит побитово в эту область памяти некотурую информацию
	//Создает узел, Node, который сохраняет ссылку на эту область памяти и размер данной памяти
	//С помощью цикла и с помощью проверки указателей на область памяти у iter и у prevNode (для нахождения нужной позиции в списке)
	//находим нужную позицию. Проверкой является сравнение этих указателей итератора и узла.
	//В случае нахождения, на эту позицию ставиться новый узел. Меняем указатели на ближних узлах
	//Увеличивает счетчик занятой памяти (mem_Size_List) в MemoryManager и инкрементирует счетчик узлов в списке (list_Size)
	int insert(Iterator* iter, void* elem, size_t elemSize); 

	//Меотды из Container.h

	//возвращет количество элементов в списке 
	//возвращает поле list_Size
	int size();                

	//Функция возвращает значение, равное максимальной вместимости контейнера в байтах
	//Возвращает значение, которое возвращает метод MemoryManager, а точнее метод _memory.size()
	size_t max_bytes();                                           

	//создание итератора, который указывает на элемент списка, который содержит в себе elem
	// Принимает указатель на область памяти, где храниться элемент, который мы ищем, и его размер в байтах. 
	//Создается итератор, который и будет возвращен
	//В цикле с помощью побитового сравнения двух областей памяти, а точнее elem и Node::elem.
	//Если данный узел не является искомым, проверяется наличие слудеющего элемента. (hasNext())
	//В случае его присутсвия - переходим в него. (goToNext())
	//В противном - возвращаем nullptr
	Iterator* find(void* elem, size_t size);

	// создание итератора, который указывает на первый элемент в списке
	//создается итератор типа List::Iterator
	//В случае, если head == nullptr, возвращает nullptr
	Iterator* newIterator();              

	//Удаление элемента с позиции на который указывает итератор
	//После удаления итератор указывает на следующий за удаленным элемент.
	//Если список пуст, то вызывается исключение EmptyError
	//Если возникли проблемы с итератором, и он стал не валидным вызывается исключение IterEmpty
	//Случаи, когда итератор может стать не валидным, смотри в List.h
	void remove(Container::Iterator* iter);    

	//удаление всех элементов в списке
	//циклично использует pop_front()
	//Заканчивается, как только hasNext() говорит, что нет следующего элемента.
	void clear();												  
};

